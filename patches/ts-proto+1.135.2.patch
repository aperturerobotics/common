diff --git a/node_modules/ts-proto/build/generate-grpc-web.js b/node_modules/ts-proto/build/generate-grpc-web.js
index c0669e1..d23db07 100644
--- a/node_modules/ts-proto/build/generate-grpc-web.js
+++ b/node_modules/ts-proto/build/generate-grpc-web.js
@@ -107,7 +107,11 @@ function generateGrpcMethodDesc(ctx, serviceDesc, methodDesc) {
     // we want/what grpc-web's runtime needs.
     const responseFn = (0, ts_poet_1.code) `{
     deserializeBinary(data: Uint8Array) {
-      return { ...${outputType}.decode(data), toObject() { return this; } };
+      const value = ${outputType}.decode(data);
+      return {
+        ...value,
+        toObject() { return value; },
+      };
     }
   }`;
     return (0, ts_poet_1.code) `
@@ -217,7 +221,7 @@ function createPromiseUnaryMethod(ctx) {
           debug: this.options.debug,
           onEnd: function (response) {
             if (response.status === grpc.Code.OK) {
-              resolve(response.message);
+              resolve(response.message!.toObject());
             } else {
               const err = new ${ctx.utils.GrpcWebError}(response.statusMessage, response.status, response.trailers);
               reject(err);
diff --git a/node_modules/ts-proto/build/generate-services.js b/node_modules/ts-proto/build/generate-services.js
index e9f7077..882cb7d 100644
--- a/node_modules/ts-proto/build/generate-services.js
+++ b/node_modules/ts-proto/build/generate-services.js
@@ -39,6 +39,9 @@ function generateService(ctx, fileDesc, sourceInfo, serviceDesc) {
         const partialInput = options.outputClientImpl === "grpc-web";
         const inputType = (0, types_1.requestType)(ctx, methodDesc, partialInput);
         params.push((0, ts_poet_1.code) `request: ${inputType}`);
+        if (options.useAbortSignal) {
+            params.push((0, ts_poet_1.code) `abortSignal?: AbortSignal`);
+        }
         // Use metadata as last argument for interface only configuration
         if (options.outputClientImpl === "grpc-web") {
             // We have to use grpc.Metadata where grpc will come from @improbable-eng
@@ -72,16 +75,20 @@ function generateService(ctx, fileDesc, sourceInfo, serviceDesc) {
     return (0, ts_poet_1.joinCode)(chunks, { on: "\n" });
 }
 exports.generateService = generateService;
-function generateRegularRpcMethod(ctx, fileDesc, serviceDesc, methodDesc) {
+function generateRegularRpcMethod(ctx, methodDesc) {
     (0, utils_1.assertInstanceOf)(methodDesc, utils_1.FormattedMethodDescriptor);
-    const { options, utils } = ctx;
+    const { options } = ctx;
     const Reader = (0, utils_1.impFile)(ctx.options, "Reader@protobufjs/minimal");
     const rawInputType = (0, types_1.rawRequestType)(ctx, methodDesc, { keepValueType: true });
     const inputType = (0, types_1.requestType)(ctx, methodDesc);
-    const outputType = (0, types_1.responseType)(ctx, methodDesc);
     const rawOutputType = (0, types_1.responseType)(ctx, methodDesc, { keepValueType: true });
-    const params = [...(options.context ? [(0, ts_poet_1.code) `ctx: Context`] : []), (0, ts_poet_1.code) `request: ${inputType}`];
+    const params = [
+        ...(options.context ? [(0, ts_poet_1.code) `ctx: Context`] : []),
+        (0, ts_poet_1.code) `request: ${inputType}`,
+        ...(options.useAbortSignal ? [(0, ts_poet_1.code) `abortSignal?: AbortSignal`] : [])
+    ];
     const maybeCtx = options.context ? "ctx," : "";
+    const maybeAbortSignal = options.useAbortSignal ? "abortSignal || undefined," : "";
     let encode = (0, ts_poet_1.code) `${rawInputType}.encode(request).finish()`;
     let decode = (0, ts_poet_1.code) `data => ${rawOutputType}.decode(new ${Reader}(data))`;
     // if (options.useDate && rawOutputType.toString().includes("Timestamp")) {
@@ -131,7 +138,8 @@ function generateRegularRpcMethod(ctx, fileDesc, serviceDesc, methodDesc) {
         ${maybeCtx}
         this.service,
         "${methodDesc.name}",
-        data
+        data,
+        ${maybeAbortSignal}
       );
       return ${decode};
     }
@@ -172,7 +180,7 @@ function generateServiceClientImpl(ctx, fileDesc, serviceDesc) {
             chunks.push(generateCachingRpcMethod(ctx, fileDesc, serviceDesc, methodDesc));
         }
         else {
-            chunks.push(generateRegularRpcMethod(ctx, fileDesc, serviceDesc, methodDesc));
+            chunks.push(generateRegularRpcMethod(ctx, methodDesc));
         }
     }
     chunks.push((0, ts_poet_1.code) `}`);
@@ -267,6 +275,7 @@ function generateRpcType(ctx, hasStreamingMethods) {
     const { options } = ctx;
     const maybeContext = options.context ? "<Context>" : "";
     const maybeContextParam = options.context ? "ctx: Context," : "";
+    const maybeAbortSignalParam = options.useAbortSignal ? "abortSignal?: AbortSignal," : "";
     const methods = [[(0, ts_poet_1.code) `request`, (0, ts_poet_1.code) `Uint8Array`, (0, ts_poet_1.code) `Promise<Uint8Array>`]];
     if (hasStreamingMethods) {
         const observable = (0, types_1.observableType)(ctx);
@@ -286,7 +295,8 @@ function generateRpcType(ctx, hasStreamingMethods) {
         ${maybeContextParam}
         service: string,
         method: string,
-        data: ${method[1]}
+        data: ${method[1]},
+        ${maybeAbortSignalParam}
       ): ${method[2]};`);
     });
     chunks.push((0, ts_poet_1.code) `    }`);
diff --git a/node_modules/ts-proto/build/main.js b/node_modules/ts-proto/build/main.js
index 9b5c5fa..df55639 100644
--- a/node_modules/ts-proto/build/main.js
+++ b/node_modules/ts-proto/build/main.js
@@ -74,7 +74,7 @@ function generateFile(ctx, fileDesc) {
     }
     if (options.outputEncodeMethods || options.outputJsonMethods || options.outputTypeRegistry) {
         // then add the encoder/decoder/base instance
-        (0, visit_1.visit)(fileDesc, sourceInfo, (fullName, message, sInfo, fullProtoTypeName) => {
+        (0, visit_1.visit)(fileDesc, sourceInfo, (fullName, message, _sInfo, fullProtoTypeName) => {
             const fullTypeName = (0, utils_1.maybePrefixPackage)(fileDesc, fullProtoTypeName);
             chunks.push(generateBaseInstanceFactory(ctx, fullName, message, fullTypeName));
             const staticMembers = [];
@@ -170,7 +170,7 @@ function generateFile(ctx, fileDesc) {
                 }
             });
         }
-        serviceDesc.method.forEach((methodDesc, index) => {
+        serviceDesc.method.forEach((methodDesc, _index) => {
             if (methodDesc.serverStreaming || methodDesc.clientStreaming) {
                 hasStreamingMethods = true;
             }
@@ -220,7 +220,7 @@ function makeUtils(options) {
     return {
         ...bytes,
         ...makeDeepPartial(options, longs),
-        ...makeObjectIdMethods(options),
+        ...makeObjectIdMethods(),
         ...makeTimestampMethods(options, longs),
         ...longs,
         ...makeComparisonUtils(),
@@ -375,7 +375,7 @@ function makeDeepPartial(options, longs) {
     `);
     return { Builtin, DeepPartial, Exact };
 }
-function makeObjectIdMethods(options) {
+function makeObjectIdMethods() {
     const mongodb = (0, ts_poet_1.imp)("mongodb*mongodb");
     const fromProtoObjectId = (0, ts_poet_1.conditionalOutput)("fromProtoObjectId", (0, ts_poet_1.code) `
       function fromProtoObjectId(oid: ObjectId): ${mongodb}.ObjectId {
diff --git a/node_modules/ts-proto/build/options.js b/node_modules/ts-proto/build/options.js
index be7c44c..0bbef51 100644
--- a/node_modules/ts-proto/build/options.js
+++ b/node_modules/ts-proto/build/options.js
@@ -66,6 +66,7 @@ function defaultOptions() {
         onlyTypes: false,
         emitImportedFiles: true,
         useExactTypes: true,
+        useAbortSignal: false,
         useAsyncIterable: false,
         unknownFields: false,
         usePrototypeForDefaults: false,
diff --git a/node_modules/ts-proto/build/sourceInfo.js b/node_modules/ts-proto/build/sourceInfo.js
index de39b7c..25a5f16 100644
--- a/node_modules/ts-proto/build/sourceInfo.js
+++ b/node_modules/ts-proto/build/sourceInfo.js
@@ -45,11 +45,6 @@ class EmptyDescription {
  * defined in a protocol buffer.
  */
 class SourceInfo {
-    // Private
-    constructor(sourceCode, selfDescription) {
-        this.sourceCode = sourceCode;
-        this.selfDescription = selfDescription;
-    }
     /** Returns an empty SourceInfo */
     static empty() {
         return new SourceInfo({}, new EmptyDescription());
@@ -68,6 +63,11 @@ class SourceInfo {
         }
         return new SourceInfo(map, new EmptyDescription());
     }
+    // Private
+    constructor(sourceCode, selfDescription) {
+        this.sourceCode = sourceCode;
+        this.selfDescription = selfDescription;
+    }
     /** Returns the code span [start line, start column, end line] */
     get span() {
         return this.selfDescription.span;
diff --git a/node_modules/ts-proto/build/utils.js b/node_modules/ts-proto/build/utils.js
index f01d37c..ba3cf39 100644
--- a/node_modules/ts-proto/build/utils.js
+++ b/node_modules/ts-proto/build/utils.js
@@ -105,6 +105,13 @@ exports.assertInstanceOf = assertInstanceOf;
  * A MethodDescriptorProto subclass that adds formatted properties
  */
 class FormattedMethodDescriptor {
+    /**
+     * The name of this method with formatting applied according to the `Options` object passed to the constructor.
+     * Automatically updates to any changes to the `Options` or `name` of this object
+     */
+    get formattedName() {
+        return FormattedMethodDescriptor.formatName(this.name, this.ctxOptions);
+    }
     constructor(src, options) {
         this.ctxOptions = options;
         this.original = src;
@@ -115,13 +122,6 @@ class FormattedMethodDescriptor {
         this.clientStreaming = src.clientStreaming;
         this.serverStreaming = src.serverStreaming;
     }
-    /**
-     * The name of this method with formatting applied according to the `Options` object passed to the constructor.
-     * Automatically updates to any changes to the `Options` or `name` of this object
-     */
-    get formattedName() {
-        return FormattedMethodDescriptor.formatName(this.name, this.ctxOptions);
-    }
     /**
      * Retrieve the source `MethodDescriptorProto` used to construct this object
      * @returns The source `MethodDescriptorProto` used to construct this object
